# group_ex.py

# 집합

# 집합은 정해진 규칙으로 출력되지않는다.
num = {'one', 'two', 'three'}
type(num)
print(num)

# 집합의 갯수
len(num)

# 집합을 만들기
set1 = set()

# 집합을 출력
print(set1)

# 집합의 길이
# 집합에 튜플이 들어간다
s1 = {1, 2, 3, (1, 2, 3), 4}
len(s1)

# 리스트는 집합의 요소가 될수 없다.
""" s2 = {1,2,3,[1,2,3],4} """

# s1의 집합에 6을 추가.
s1.add(6)
print(s1)   # 집합은 순서가 없다

# 집합에서 삭제하는 메소드
s1.discard(1)
print(s1)

# 집합에서 삭제하는 메소드2
s1.remove(3)
print(s1)

# discard 메서드를 사용했을 때 8을 가지고 있지 않아도 출력을 시키면 에러를 내지않지만
s1.discard(8)
print(s1)

# remove 메서드는 에러를 띄운다
"""s1.remove(8)"""

# 집합에서 임의의값으로 빼주는 메서드
num = s1.pop()
print(num)

# 집합을 복사하는 메서드
# 카피를 사용하면 메모리가 다르다.
set1 = {100, 200, 300, 400}
set2 = set1.copy()
print(set2)

# 메모리의 주소값을 확인 할 수 있는 메서드
id(set1), id(set2)

# 참조하는 경우는 메모리 주소값이 같다.
s1 = {1, 2, 3}
s2 = s1
id(s1), id(s2)

# 모든 요소를 삭제한다.
s1.clear()
print(s1, s2)

# 카피를 했을 경우 다른 메모리 주소값을 지닌다.
# set1 을 클리어메서드를 사용하여도 set2 메모리는 남아있다.
set1.clear()
print(set1, set2)

# s1 의 원소와 s2 의 원소가 같음으로 일치한다
s1 = {1, 2, 3}
s2 = {3, 2, 1}
print(s1 == s2)

# 집합에서의 관계연산자는 부분집합을 의미한다.
s3 = {1, 2, 3, 4, 5}
s1 < s3
s1 > s3

# issubset 을 사용하면 부분집합을 확인하는 메서드.
s1.issubset(s3)

# 집합에서는 in 연산자도 사용 할 수 있다.
5 in s3

# 합집합을 사용할떄 | 기호를 사용
s1 = {1, 2, 3}
s2 = {2, 4, 5}
s1 | s2

# 합집합을 메서드로 사용할 때
s1.union(s2)

# 교집합
s1 & s2

# 교집합을 메서드로 사용할 때
s1.intersection(s2)

# 차집합을 기호로 사용할 때
s1-s2

# 차집합을 메서드로 사용할 때
s1.difference(s2)

